[
  {
    "id": "java_001",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM?",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_002",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'?",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_003",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java.",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_004",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions?",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_005",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword?",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_006",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer?",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_007",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance?",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_008",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces?",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_009",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for?",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_010",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement.",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_011",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java?",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_012",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding?",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_013",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally?",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_014",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor?",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_015",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface?",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_16",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 16)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_17",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 17)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_18",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 18)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_19",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 19)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_20",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 20)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_21",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 21)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_22",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 22)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_23",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 23)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_24",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 24)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_25",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 25)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_26",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 26)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_27",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 27)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_28",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 28)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_29",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 29)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_30",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 30)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_31",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 31)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_32",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 32)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_33",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 33)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_34",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 34)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_35",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 35)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_36",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 36)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_37",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 37)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_38",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 38)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_39",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 39)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_40",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 40)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_41",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 41)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_42",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 42)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_43",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 43)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_44",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 44)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_45",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 45)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_46",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 46)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_47",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 47)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_48",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 48)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_49",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 49)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_50",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 50)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_51",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 51)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_52",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 52)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_53",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 53)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_54",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 54)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_55",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 55)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_56",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 56)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_57",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 57)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_58",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 58)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_59",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 59)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_60",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 60)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_61",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 61)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_62",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 62)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_63",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 63)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_64",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 64)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_65",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 65)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_66",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 66)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_67",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 67)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_68",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 68)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_69",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 69)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_70",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 70)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_71",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 71)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_72",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 72)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_73",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 73)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_74",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 74)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_75",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 75)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_76",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 76)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_77",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 77)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_78",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 78)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_79",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 79)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_80",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 80)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_81",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 81)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_82",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 82)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_83",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 83)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_84",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 84)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_85",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 85)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_86",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 86)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_87",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 87)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_88",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 88)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_89",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 89)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_90",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 90)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_91",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 91)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_92",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 92)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_93",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 93)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_94",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 94)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_95",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 95)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_96",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 96)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_97",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 97)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_98",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 98)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_99",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 99)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_100",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 100)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_101",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 101)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_102",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 102)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_103",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 103)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_104",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 104)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_105",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 105)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_106",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 106)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_107",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 107)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_108",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 108)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_109",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 109)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_110",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 110)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_111",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 111)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_112",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 112)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_113",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 113)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_114",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 114)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_115",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 115)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_116",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 116)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_117",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 117)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_118",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 118)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_119",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 119)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_120",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 120)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_121",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 121)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_122",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 122)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_123",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 123)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_124",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 124)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_125",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 125)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_126",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 126)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_127",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 127)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_128",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 128)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_129",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 129)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_130",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 130)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_131",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 131)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_132",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 132)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_133",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 133)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_134",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 134)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_135",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 135)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_136",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 136)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_137",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 137)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_138",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 138)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_139",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 139)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_140",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 140)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_141",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 141)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_142",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 142)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_143",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 143)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_144",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 144)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_145",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 145)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_146",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 146)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_147",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 147)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_148",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 148)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_149",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 149)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_150",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 150)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_151",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 151)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_152",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 152)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_153",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 153)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_154",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 154)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_155",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 155)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_156",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 156)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_157",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 157)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_158",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 158)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_159",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 159)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_160",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 160)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_161",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 161)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_162",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 162)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_163",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 163)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_164",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 164)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_165",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 165)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_166",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 166)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_167",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 167)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_168",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 168)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_169",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 169)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_170",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 170)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_171",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 171)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_172",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 172)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_173",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 173)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_174",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 174)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_175",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 175)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_176",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 176)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_177",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 177)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_178",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 178)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_179",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 179)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_180",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 180)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_181",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 181)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_182",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 182)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_183",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 183)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_184",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 184)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_185",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 185)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_186",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 186)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_187",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 187)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_188",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 188)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_189",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 189)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_190",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 190)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_191",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 191)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_192",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 192)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_193",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 193)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_194",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 194)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_195",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 195)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_196",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 196)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_197",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 197)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_198",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 198)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_199",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 199)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_200",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 200)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_201",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 201)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_202",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 202)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_203",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 203)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_204",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 204)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_205",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 205)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_206",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 206)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_207",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 207)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_208",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 208)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_209",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 209)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_210",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 210)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_211",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 211)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_212",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 212)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_213",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 213)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_214",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 214)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_215",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 215)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_216",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 216)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_217",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 217)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_218",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 218)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_219",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 219)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_220",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 220)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_221",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 221)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_222",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 222)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_223",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 223)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_224",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 224)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_225",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 225)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_226",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 226)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_227",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 227)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_228",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 228)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_229",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 229)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_230",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 230)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_231",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 231)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_232",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 232)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_233",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 233)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_234",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 234)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_235",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 235)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_236",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 236)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_237",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 237)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_238",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 238)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_239",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 239)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_240",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 240)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_241",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 241)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_242",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 242)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_243",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 243)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_244",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 244)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_245",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 245)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_246",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 246)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_247",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 247)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_248",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 248)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_249",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 249)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_250",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 250)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_251",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 251)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_252",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 252)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_253",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 253)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_254",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 254)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_255",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 255)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_256",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 256)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_257",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 257)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_258",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 258)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_259",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 259)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_260",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 260)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_261",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 261)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_262",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 262)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_263",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 263)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_264",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 264)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_265",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 265)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_266",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 266)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_267",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 267)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_268",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 268)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_269",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 269)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_270",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 270)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_271",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 271)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_272",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 272)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_273",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 273)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_274",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 274)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_275",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 275)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_276",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 276)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_277",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 277)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_278",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 278)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_279",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 279)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_280",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 280)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_281",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 281)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_282",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 282)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_283",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 283)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_284",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 284)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_285",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 285)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_286",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 286)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_287",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 287)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_288",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 288)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_289",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 289)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_290",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 290)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_291",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 291)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_292",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 292)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_293",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 293)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_294",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 294)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_295",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 295)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_296",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 296)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_297",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 297)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_298",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 298)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_299",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 299)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_300",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 300)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_301",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 301)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_302",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 302)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_303",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 303)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_304",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 304)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_305",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 305)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_306",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 306)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_307",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 307)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_308",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 308)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_309",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 309)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_310",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 310)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_311",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 311)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_312",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 312)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_313",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 313)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_314",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 314)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_315",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 315)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_316",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 316)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_317",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 317)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_318",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 318)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_319",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 319)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_320",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 320)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_321",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 321)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_322",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 322)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_323",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 323)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_324",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 324)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_325",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 325)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_326",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 326)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_327",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 327)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_328",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 328)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_329",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 329)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_330",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 330)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_331",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 331)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_332",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 332)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_333",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 333)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_334",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 334)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_335",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 335)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_336",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 336)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_337",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 337)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_338",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 338)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_339",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 339)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_340",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 340)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_341",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 341)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_342",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 342)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_343",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 343)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_344",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 344)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_345",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 345)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_346",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 346)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_347",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 347)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_348",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 348)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_349",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 349)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_350",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 350)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_351",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 351)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_352",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 352)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_353",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 353)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_354",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 354)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_355",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 355)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_356",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 356)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_357",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 357)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_358",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 358)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_359",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 359)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_360",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 360)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_361",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 361)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_362",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 362)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_363",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 363)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_364",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 364)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_365",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 365)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_366",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 366)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_367",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 367)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_368",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 368)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_369",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 369)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_370",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 370)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_371",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 371)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_372",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 372)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_373",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 373)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_374",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 374)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_375",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 375)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_376",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 376)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_377",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 377)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_378",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 378)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_379",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 379)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_380",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 380)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_381",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 381)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_382",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 382)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_383",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 383)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_384",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 384)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_385",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 385)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_386",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 386)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_387",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 387)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_388",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 388)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_389",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 389)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_390",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 390)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_391",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 391)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_392",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 392)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_393",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 393)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_394",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 394)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_395",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 395)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_396",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 396)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_397",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 397)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_398",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 398)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_399",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 399)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_400",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 400)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_401",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 401)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_402",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 402)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_403",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 403)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_404",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 404)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_405",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 405)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_406",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 406)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_407",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 407)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_408",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 408)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_409",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 409)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_410",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 410)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_411",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 411)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_412",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 412)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_413",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 413)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_414",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 414)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_415",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 415)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_416",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 416)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_417",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 417)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_418",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 418)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_419",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 419)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_420",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 420)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_421",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 421)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_422",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 422)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_423",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 423)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_424",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 424)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_425",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 425)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_426",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 426)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_427",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 427)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_428",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 428)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_429",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 429)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_430",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 430)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_431",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 431)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_432",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 432)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_433",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 433)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_434",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 434)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_435",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 435)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_436",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 436)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_437",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 437)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_438",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 438)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_439",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 439)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_440",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 440)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_441",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 441)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_442",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 442)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_443",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 443)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_444",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 444)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_445",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 445)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_446",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 446)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_447",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 447)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_448",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 448)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_449",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 449)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_450",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 450)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_451",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 451)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_452",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 452)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_453",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 453)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_454",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 454)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_455",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 455)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_456",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 456)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_457",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 457)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_458",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 458)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_459",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 459)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_460",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 460)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_461",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 461)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_462",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 462)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_463",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 463)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_464",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 464)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_465",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 465)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_466",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 466)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_467",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 467)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_468",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 468)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_469",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 469)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_470",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 470)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_471",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 471)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_472",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 472)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_473",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 473)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_474",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 474)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_475",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 475)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_476",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 476)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_477",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 477)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_478",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 478)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_479",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 479)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_480",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 480)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_481",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 481)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_482",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 482)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_483",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 483)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_484",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 484)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_485",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 485)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_486",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 486)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_487",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 487)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_488",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 488)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_489",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 489)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_490",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 490)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_491",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 491)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_492",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 492)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_493",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 493)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_494",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 494)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_495",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 495)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_496",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 496)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_497",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 497)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_498",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 498)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_499",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 499)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_500",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 500)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_501",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 501)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_502",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 502)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_503",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 503)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_504",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 504)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_505",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 505)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_506",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 506)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_507",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 507)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_508",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 508)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_509",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 509)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_510",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 510)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_511",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 511)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_512",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 512)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_513",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 513)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_514",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 514)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_515",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 515)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_516",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 516)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_517",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 517)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_518",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 518)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_519",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 519)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_520",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 520)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_521",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 521)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_522",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 522)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_523",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 523)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_524",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 524)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_525",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 525)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_526",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 526)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_527",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 527)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_528",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 528)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_529",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 529)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_530",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 530)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_531",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 531)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_532",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 532)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_533",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 533)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_534",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 534)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_535",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 535)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_536",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 536)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_537",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 537)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_538",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 538)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_539",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 539)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_540",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 540)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_541",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 541)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_542",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 542)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_543",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 543)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_544",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 544)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_545",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 545)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_546",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 546)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_547",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 547)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_548",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 548)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_549",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 549)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_550",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 550)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_551",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 551)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_552",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 552)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_553",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 553)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_554",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 554)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_555",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 555)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_556",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 556)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_557",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 557)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_558",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 558)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_559",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 559)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_560",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 560)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_561",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 561)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_562",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 562)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_563",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 563)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_564",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 564)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_565",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 565)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_566",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 566)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_567",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 567)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_568",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 568)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_569",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 569)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_570",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 570)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_571",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 571)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_572",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 572)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_573",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 573)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_574",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 574)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_575",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 575)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_576",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 576)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_577",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 577)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_578",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 578)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_579",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 579)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_580",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 580)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_581",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 581)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_582",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 582)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_583",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 583)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_584",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 584)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_585",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 585)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_586",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 586)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_587",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 587)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_588",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 588)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_589",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 589)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_590",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 590)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_591",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 591)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_592",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 592)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_593",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 593)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_594",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 594)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_595",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 595)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_596",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 596)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_597",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 597)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_598",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 598)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_599",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 599)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_600",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 600)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_601",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 601)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_602",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 602)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_603",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 603)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_604",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 604)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_605",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 605)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_606",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 606)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_607",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 607)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_608",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 608)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_609",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 609)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_610",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 610)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_611",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 611)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_612",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 612)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_613",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 613)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_614",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 614)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_615",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 615)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_616",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 616)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_617",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 617)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_618",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 618)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_619",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 619)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_620",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 620)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_621",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 621)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_622",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 622)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_623",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 623)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_624",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 624)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_625",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 625)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_626",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 626)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_627",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 627)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_628",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 628)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_629",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 629)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_630",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 630)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_631",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 631)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_632",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 632)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_633",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 633)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_634",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 634)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_635",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 635)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_636",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 636)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_637",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 637)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_638",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 638)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_639",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 639)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_640",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 640)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_641",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 641)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_642",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 642)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_643",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 643)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_644",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 644)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_645",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 645)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_646",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 646)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_647",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 647)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_648",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 648)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_649",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 649)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_650",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 650)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_651",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 651)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_652",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 652)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_653",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 653)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_654",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 654)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_655",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 655)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_656",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 656)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_657",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 657)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_658",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 658)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_659",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 659)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_660",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 660)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_661",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 661)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_662",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 662)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_663",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 663)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_664",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 664)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_665",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 665)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_666",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 666)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_667",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 667)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_668",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 668)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_669",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 669)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_670",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 670)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_671",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 671)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_672",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 672)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_673",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 673)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_674",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 674)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_675",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 675)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_676",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 676)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_677",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 677)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_678",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 678)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_679",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 679)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_680",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 680)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_681",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 681)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_682",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 682)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_683",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 683)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_684",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 684)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_685",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 685)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_686",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 686)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_687",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 687)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_688",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 688)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_689",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 689)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_690",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 690)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_691",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 691)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_692",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 692)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_693",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 693)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_694",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 694)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_695",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 695)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_696",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 696)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_697",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 697)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_698",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 698)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_699",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 699)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_700",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 700)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_701",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 701)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_702",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 702)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_703",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 703)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_704",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 704)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_705",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 705)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_706",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 706)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_707",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 707)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_708",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 708)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_709",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 709)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_710",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 710)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_711",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 711)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_712",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 712)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_713",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 713)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_714",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 714)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_715",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 715)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_716",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 716)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_717",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 717)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_718",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 718)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_719",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 719)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_720",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 720)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_721",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 721)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_722",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 722)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_723",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 723)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_724",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 724)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_725",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 725)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_726",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 726)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_727",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 727)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_728",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 728)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_729",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 729)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_730",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 730)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_731",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 731)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_732",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 732)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_733",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 733)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_734",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 734)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_735",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 735)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_736",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 736)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_737",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 737)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_738",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 738)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_739",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 739)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_740",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 740)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_741",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 741)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_742",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 742)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_743",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 743)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_744",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 744)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_745",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 745)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_746",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 746)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_747",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 747)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_748",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 748)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_749",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 749)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_750",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 750)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_751",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 751)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_752",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 752)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_753",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 753)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_754",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 754)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_755",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 755)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_756",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 756)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_757",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 757)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_758",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 758)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_759",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 759)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_760",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 760)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_761",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 761)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_762",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 762)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_763",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 763)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_764",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 764)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_765",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 765)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_766",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 766)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_767",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 767)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_768",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 768)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_769",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 769)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_770",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 770)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_771",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 771)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_772",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 772)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_773",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 773)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_774",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 774)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_775",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 775)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_776",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 776)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_777",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 777)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_778",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 778)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_779",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 779)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_780",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 780)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_781",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 781)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_782",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 782)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_783",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 783)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_784",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 784)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_785",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 785)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_786",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 786)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_787",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 787)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_788",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 788)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_789",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 789)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_790",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 790)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_791",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 791)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_792",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 792)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_793",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 793)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_794",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 794)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_795",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 795)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_796",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 796)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_797",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 797)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_798",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 798)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_799",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 799)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_800",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 800)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_801",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 801)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_802",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 802)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_803",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the 'final' keyword used for? (Variation 803)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_804",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 804)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_805",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 805)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_806",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 806)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_807",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 807)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_808",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 808)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_809",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 809)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_810",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 810)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_811",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 811)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_812",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 812)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_813",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 813)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_814",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 814)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_815",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 815)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_816",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 816)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_817",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 817)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_818",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 818)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_819",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 819)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_820",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 820)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_821",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 821)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_822",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 822)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_823",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 823)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_824",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 824)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_825",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 825)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_826",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 826)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_827",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 827)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_828",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 828)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_829",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 829)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_830",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 830)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_831",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 831)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_832",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 832)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_833",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 833)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_834",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 834)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_835",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 835)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_836",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 836)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_837",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 837)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_838",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 838)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_839",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 839)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_840",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 840)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_841",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 841)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_842",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 842)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_843",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 843)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_844",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 844)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_845",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 845)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_846",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 846)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_847",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 847)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_848",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 848)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_849",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 849)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_850",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 850)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_851",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 851)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_852",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 852)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_853",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 853)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_854",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 854)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_855",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 855)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_856",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 856)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_857",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 857)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_858",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 858)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_859",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 859)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_860",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 860)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_861",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 861)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_862",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 862)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_863",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 863)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_864",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 864)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_865",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 865)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_866",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 866)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_867",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 867)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_868",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 868)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_869",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 869)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_870",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 870)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_871",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 871)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_872",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 872)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_873",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 873)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_874",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 874)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_875",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 875)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_876",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 876)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_877",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 877)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_878",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 878)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_879",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 879)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_880",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 880)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_881",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 881)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_882",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 882)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_883",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 883)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_884",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 884)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_885",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 885)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_886",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 886)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_887",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 887)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_888",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 888)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_889",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 889)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_890",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 890)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_891",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 891)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_892",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the try-with-resources statement. (Variation 892)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_893",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 893)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_894",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 894)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_895",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 895)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_896",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 896)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_897",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 897)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_898",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What are the access modifiers in Java? (Variation 898)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_899",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 899)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_900",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 900)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_901",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 901)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_902",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 902)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_903",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 903)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_904",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 904)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_905",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 905)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_906",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 906)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_907",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 907)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_908",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 908)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_909",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 909)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_910",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 910)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_911",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 911)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_912",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 912)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_913",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 913)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_914",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 914)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_915",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 915)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_916",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 916)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_917",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 917)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_918",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 918)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_919",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 919)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_920",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 920)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_921",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 921)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_922",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 922)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_923",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 923)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_924",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 924)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_925",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 925)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_926",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 926)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_927",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 927)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_928",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 928)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_929",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 929)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_930",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 930)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_931",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 931)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_932",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 932)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_933",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 933)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_934",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 934)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_935",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 935)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_936",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Does Java support multiple inheritance? (Variation 936)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_937",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between abstract class and interface? (Variation 937)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_938",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 938)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_939",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between abstract class and interface? (Variation 939)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_940",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What are the access modifiers in Java? (Variation 940)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_941",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What are the access modifiers in Java? (Variation 941)",
    "answer": "1. Private: Accessible only within the class. 2. Default (no modifier): Accessible within the package. 3. Protected: Accessible within package and subclasses. 4. Public: Accessible everywhere.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_942",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 942)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_943",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 943)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_944",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 944)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_945",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 945)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_946",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 946)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_947",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between abstract class and interface? (Variation 947)",
    "answer": "Abstract class can have state (fields) and constructors, supports single inheritance. Interface (pre-Java 8) only constant variables and abstract methods; supports multiple inheritance. Java 8+ interfaces can have default/static methods.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_948",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 948)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_949",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 949)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_950",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is a constructor? (Variation 950)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_951",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 951)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_952",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 952)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_953",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is a constructor? (Variation 953)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_954",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 954)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_955",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 955)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_956",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 956)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_957",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 957)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_958",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Does Java support multiple inheritance? (Variation 958)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_959",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 959)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_960",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 960)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_961",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 961)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_962",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the try-with-resources statement. (Variation 962)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_963",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 963)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_964",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between StringBuilder and StringBuffer? (Variation 964)",
    "answer": "StringBuffer is synchronized (thread-safe) and thus slower. StringBuilder is not synchronized (not thread-safe) but faster. Use StringBuilder when thread safety is not an issue.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_965",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 965)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_966",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 966)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_967",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 967)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_968",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 968)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_969",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 969)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_970",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 970)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_971",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between '==' and '.equals()'? (Variation 971)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_972",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between JDK, JRE, and JVM? (Variation 972)",
    "answer": "JDK (Java Development Kit) is a full featured software development kit for Java, including JRE and compilers/tools. JRE (Java Runtime Environment) provides the libraries, JVM, and other components to run applets and applications written in Java. JVM (Java Virtual Machine) is an abstract machine that provides a runtime environment in which Java bytecode can be executed.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_973",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 973)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_974",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 974)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_975",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is method overloading vs method overriding? (Variation 975)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_976",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 976)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_977",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between '==' and '.equals()'? (Variation 977)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_978",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "How does HashMap work internally? (Variation 978)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_979",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 979)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_980",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 980)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_981",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 981)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_982",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 982)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_983",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "How does HashMap work internally? (Variation 983)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_984",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the 'final' keyword used for? (Variation 984)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_985",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between '==' and '.equals()'? (Variation 985)",
    "answer": "'==' is an operator that compares the memory addresses (references) of two objects to check if they point to the same instance. '.equals()' is a method that is used to compare the contents of the objects (logical equality). The default implementation of .equals() in Object class uses ==, but it is often overridden (e.g., in String class).",
    "codeSnippet": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2); // false\nSystem.out.println(s1.equals(s2)); // true"
  },
  {
    "id": "java_gen_986",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Comparator and Comparable interfaces? (Variation 986)",
    "answer": "Comparable provides a natural ordering for a class (implement compareTo method). Comparator provides a custom ordering and can be implemented in a separate class (implement compare method).",
    "codeSnippet": "public class SortByName implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}"
  },
  {
    "id": "java_gen_987",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Does Java support multiple inheritance? (Variation 987)",
    "answer": "Java does not support multiple inheritance of classes to avoid the 'Diamond Problem'. However, it supports multiple inheritance of interfaces (a class can implement multiple interfaces).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_988",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 988)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_989",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "Explain the try-with-resources statement. (Variation 989)",
    "answer": "Introduced in Java 7, it ensures that each resource (which must implement AutoCloseable) is closed at the end of the statement, eliminating the need for a finally block to close resources.",
    "codeSnippet": "try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n}"
  },
  {
    "id": "java_gen_990",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the 'final' keyword used for? (Variation 990)",
    "answer": "1. Variable: Value cannot be changed (constant). 2. Method: Cannot be overridden. 3. Class: Cannot be inherited (subclassed).",
    "codeSnippet": "final int MAX_VALUE = 100;"
  },
  {
    "id": "java_gen_991",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 991)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_992",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "How does HashMap work internally? (Variation 992)",
    "answer": "It uses an array of buckets. Key's hashCode determines the bucket index. If collision occurs, a linked list (or Red-Black tree after Java 8) is used to store multiple entries in the same bucket. equals() is used to find the exact key.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_993",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 993)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_994",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is method overloading vs method overriding? (Variation 994)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_995",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the difference between Checked and Unchecked Exceptions? (Variation 995)",
    "answer": "Checked exceptions are checked at compile-time (e.g., IOException, SQLException) and must be handled using try-catch or declared in the method signature. Unchecked exceptions (RuntimeExceptions like NullPointerException) are not checked at compile-time and usually represent programming errors.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_996",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 996)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_997",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "What is the purpose of the 'volatile' keyword? (Variation 997)",
    "answer": "The 'volatile' keyword indicates that a variable's value will be modified by different threads. It ensures visibility of changes to variables across threads (establishing a happens-before relationship) but does not guarantee atomicity like synchronized blocks.",
    "codeSnippet": "private volatile boolean running = true;"
  },
  {
    "id": "java_gen_998",
    "topic": "Java Core",
    "difficulty": "Basic",
    "question": "What is method overloading vs method overriding? (Variation 998)",
    "answer": "Overloading: Same method name, different parameter list (compile-time polymorphism). Overriding: Same method name and parameters in subclass (runtime polymorphism).",
    "codeSnippet": null
  },
  {
    "id": "java_gen_999",
    "topic": "Java Core",
    "difficulty": "Advanced",
    "question": "Explain the concept of 'pass by value' in Java. (Variation 999)",
    "answer": "Java is strictly 'pass by value'. When passing primitives, the actual value is copied. When passing objects, the value of the reference (memory address) is copied. This means that while method execution can modify the object targeted by the reference, it cannot reassign the original reference to a new object.",
    "codeSnippet": null
  },
  {
    "id": "java_gen_1000",
    "topic": "Java Core",
    "difficulty": "Intermediate",
    "question": "What is a constructor? (Variation 1000)",
    "answer": "A block of code similar to a method called when an instance of an object is created. It has the same name as the class and no return type.",
    "codeSnippet": null
  }
]