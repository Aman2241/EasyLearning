[
  {
    "id": "code_001",
    "topic": "Coding Challenges",
    "difficulty": "Easy",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_002",
    "topic": "Coding Challenges",
    "difficulty": "Easy",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_003",
    "topic": "Coding Challenges",
    "difficulty": "Medium",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_004",
    "topic": "Coding Challenges",
    "difficulty": "Medium",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters.",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_005",
    "topic": "Coding Challenges",
    "difficulty": "Hard",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_6",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 6)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_7",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 7)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_8",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 8)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_9",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 9)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_10",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 10)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_11",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 11)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_12",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 12)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_13",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 13)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_14",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 14)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_15",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 15)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_16",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 16)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_17",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 17)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_18",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 18)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_19",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 19)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_20",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 20)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_21",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 21)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_22",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 22)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_23",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 23)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_24",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 24)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_25",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 25)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_26",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 26)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_27",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 27)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_28",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 28)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_29",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 29)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_30",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 30)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_31",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 31)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_32",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 32)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_33",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 33)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_34",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 34)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_35",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 35)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_36",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 36)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_37",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 37)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_38",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 38)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_39",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 39)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_40",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 40)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_41",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 41)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_42",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 42)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_43",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 43)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_44",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 44)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_45",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 45)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_46",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 46)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_47",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 47)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_48",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 48)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_49",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 49)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_50",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 50)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_51",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 51)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_52",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 52)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_53",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 53)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_54",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 54)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_55",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 55)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_56",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 56)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_57",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 57)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_58",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 58)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_59",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 59)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_60",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 60)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_61",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 61)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_62",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 62)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_63",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 63)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_64",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 64)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_65",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 65)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_66",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 66)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_67",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 67)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_68",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 68)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_69",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 69)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_70",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 70)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_71",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 71)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_72",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 72)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_73",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 73)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_74",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 74)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_75",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 75)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_76",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 76)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_77",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 77)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_78",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 78)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_79",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 79)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_80",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 80)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_81",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 81)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_82",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 82)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_83",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 83)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_84",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 84)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_85",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 85)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_86",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 86)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_87",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 87)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_88",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 88)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_89",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 89)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_90",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 90)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_91",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 91)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_92",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 92)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_93",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 93)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_94",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 94)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_95",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 95)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_96",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 96)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_97",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 97)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_98",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 98)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_99",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 99)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_100",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 100)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_101",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 101)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_102",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 102)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_103",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 103)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_104",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 104)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_105",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 105)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_106",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 106)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_107",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 107)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_108",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 108)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_109",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 109)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_110",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 110)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_111",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 111)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_112",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 112)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_113",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 113)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_114",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 114)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_115",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 115)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_116",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 116)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_117",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 117)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_118",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 118)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_119",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 119)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_120",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 120)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_121",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 121)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_122",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 122)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_123",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 123)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_124",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 124)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_125",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 125)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_126",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 126)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_127",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 127)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_128",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 128)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_129",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 129)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_130",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 130)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_131",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 131)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_132",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 132)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_133",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 133)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_134",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 134)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_135",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 135)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_136",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 136)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_137",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 137)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_138",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 138)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_139",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 139)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_140",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 140)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_141",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 141)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_142",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 142)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_143",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 143)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_144",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 144)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_145",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 145)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_146",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 146)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_147",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 147)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_148",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 148)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_149",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 149)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_150",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 150)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_151",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 151)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_152",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 152)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_153",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 153)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_154",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 154)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_155",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 155)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_156",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 156)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_157",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 157)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_158",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 158)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_159",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 159)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_160",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 160)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_161",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 161)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_162",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 162)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_163",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 163)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_164",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 164)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_165",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 165)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_166",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 166)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_167",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 167)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_168",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 168)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_169",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 169)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_170",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 170)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_171",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 171)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_172",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 172)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_173",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 173)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_174",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 174)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_175",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 175)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_176",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 176)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_177",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 177)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_178",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 178)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_179",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 179)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_180",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 180)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_181",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 181)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_182",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 182)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_183",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 183)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_184",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 184)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_185",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 185)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_186",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 186)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_187",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 187)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_188",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 188)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_189",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 189)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_190",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 190)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_191",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 191)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_192",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 192)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_193",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 193)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_194",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 194)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_195",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 195)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_196",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 196)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_197",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 197)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_198",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 198)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_199",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 199)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_200",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 200)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_201",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 201)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_202",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 202)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_203",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 203)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_204",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 204)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_205",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 205)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_206",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 206)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_207",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 207)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_208",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 208)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_209",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 209)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_210",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 210)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_211",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 211)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_212",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 212)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_213",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 213)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_214",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 214)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_215",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 215)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_216",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 216)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_217",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 217)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_218",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 218)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_219",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 219)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_220",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 220)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_221",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 221)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_222",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 222)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_223",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 223)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_224",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 224)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_225",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 225)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_226",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 226)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_227",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 227)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_228",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 228)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_229",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 229)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_230",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 230)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_231",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 231)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_232",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 232)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_233",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 233)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_234",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 234)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_235",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 235)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_236",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 236)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_237",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 237)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_238",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 238)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_239",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 239)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_240",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 240)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_241",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 241)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_242",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 242)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_243",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 243)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_244",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 244)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_245",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 245)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_246",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 246)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_247",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 247)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_248",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 248)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_249",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 249)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_250",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 250)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_251",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 251)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_252",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 252)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_253",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 253)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_254",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 254)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_255",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 255)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_256",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 256)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_257",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 257)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_258",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 258)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_259",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 259)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_260",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 260)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_261",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 261)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_262",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 262)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_263",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 263)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_264",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 264)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_265",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 265)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_266",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 266)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_267",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 267)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_268",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 268)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_269",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 269)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_270",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 270)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_271",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 271)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_272",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 272)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_273",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 273)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_274",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 274)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_275",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 275)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_276",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 276)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_277",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 277)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_278",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 278)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_279",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 279)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_280",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 280)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_281",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 281)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_282",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 282)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_283",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 283)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_284",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 284)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_285",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 285)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_286",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 286)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_287",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 287)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_288",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 288)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_289",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 289)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_290",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 290)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_291",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 291)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_292",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 292)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_293",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 293)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_294",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 294)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_295",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 295)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_296",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 296)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_297",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 297)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_298",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 298)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_299",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 299)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_300",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 300)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_301",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 301)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_302",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 302)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_303",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 303)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_304",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 304)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_305",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 305)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_306",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 306)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_307",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 307)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_308",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 308)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_309",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 309)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_310",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 310)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_311",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 311)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_312",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 312)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_313",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 313)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_314",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 314)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_315",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 315)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_316",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 316)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_317",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 317)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_318",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 318)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_319",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 319)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_320",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 320)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_321",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 321)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_322",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 322)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_323",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 323)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_324",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 324)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_325",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 325)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_326",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 326)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_327",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 327)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_328",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 328)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_329",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 329)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_330",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 330)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_331",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 331)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_332",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 332)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_333",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 333)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_334",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 334)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_335",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 335)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_336",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 336)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_337",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 337)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_338",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 338)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_339",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 339)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_340",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 340)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_341",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 341)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_342",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 342)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_343",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 343)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_344",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 344)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_345",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 345)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_346",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 346)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_347",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 347)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_348",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 348)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_349",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 349)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_350",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 350)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_351",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 351)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_352",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 352)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_353",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 353)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_354",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 354)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_355",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 355)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_356",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 356)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_357",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 357)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_358",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 358)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_359",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 359)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_360",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 360)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_361",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 361)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_362",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 362)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_363",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 363)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_364",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 364)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_365",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 365)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_366",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 366)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_367",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 367)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_368",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 368)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_369",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 369)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_370",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 370)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_371",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 371)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_372",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 372)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_373",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 373)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_374",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 374)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_375",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 375)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_376",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 376)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_377",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 377)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_378",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 378)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_379",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 379)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_380",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 380)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_381",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 381)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_382",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 382)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_383",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 383)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_384",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 384)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_385",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 385)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_386",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 386)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_387",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 387)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_388",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 388)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_389",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 389)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_390",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 390)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_391",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 391)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_392",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 392)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_393",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 393)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_394",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 394)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_395",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 395)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_396",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 396)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_397",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 397)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_398",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 398)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_399",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 399)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_400",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 400)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_401",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 401)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_402",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 402)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_403",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 403)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_404",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 404)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_405",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 405)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_406",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 406)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_407",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 407)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_408",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 408)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_409",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 409)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_410",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 410)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_411",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 411)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_412",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 412)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_413",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 413)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_414",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 414)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_415",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 415)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_416",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 416)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_417",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 417)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_418",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 418)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_419",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 419)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_420",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 420)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_421",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 421)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_422",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 422)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_423",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 423)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_424",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 424)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_425",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 425)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_426",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 426)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_427",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 427)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_428",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 428)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_429",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 429)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_430",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 430)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_431",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 431)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_432",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 432)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_433",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 433)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_434",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 434)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_435",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 435)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_436",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 436)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_437",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 437)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_438",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 438)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_439",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 439)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_440",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 440)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_441",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 441)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_442",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 442)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_443",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 443)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_444",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 444)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_445",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 445)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_446",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 446)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_447",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 447)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_448",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 448)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_449",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 449)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_450",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 450)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_451",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 451)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_452",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 452)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_453",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 453)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_454",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 454)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_455",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 455)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_456",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 456)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_457",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 457)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_458",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 458)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_459",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 459)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_460",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 460)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_461",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 461)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_462",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 462)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_463",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 463)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_464",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 464)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_465",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 465)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_466",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 466)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_467",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 467)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_468",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 468)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_469",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 469)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_470",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 470)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_471",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 471)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_472",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 472)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_473",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 473)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_474",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 474)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_475",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 475)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_476",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 476)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_477",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 477)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_478",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 478)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_479",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 479)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_480",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 480)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_481",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 481)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_482",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 482)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_483",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 483)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_484",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 484)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_485",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 485)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_486",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 486)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_487",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 487)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_488",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 488)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_489",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 489)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_490",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 490)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_491",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 491)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_492",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 492)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_493",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 493)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_494",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 494)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_495",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 495)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_496",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 496)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_497",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 497)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_498",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 498)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_499",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 499)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_500",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 500)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_501",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 501)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_502",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 502)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_503",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 503)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_504",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 504)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_505",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 505)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_506",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 506)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_507",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 507)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_508",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 508)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_509",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 509)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_510",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 510)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_511",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 511)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_512",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 512)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_513",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 513)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_514",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 514)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_515",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 515)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_516",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 516)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_517",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 517)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_518",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 518)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_519",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 519)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_520",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 520)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_521",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 521)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_522",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 522)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_523",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 523)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_524",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 524)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_525",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 525)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_526",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 526)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_527",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 527)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_528",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 528)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_529",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 529)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_530",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 530)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_531",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 531)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_532",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 532)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_533",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 533)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_534",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 534)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_535",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 535)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_536",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 536)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_537",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 537)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_538",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 538)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_539",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 539)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_540",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 540)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_541",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 541)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_542",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 542)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_543",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 543)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_544",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 544)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_545",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 545)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_546",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 546)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_547",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 547)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_548",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 548)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_549",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 549)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_550",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 550)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_551",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 551)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_552",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 552)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_553",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 553)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_554",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 554)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_555",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 555)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_556",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 556)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_557",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 557)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_558",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 558)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_559",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 559)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_560",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 560)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_561",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 561)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_562",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 562)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_563",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 563)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_564",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 564)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_565",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 565)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_566",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 566)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_567",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 567)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_568",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 568)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_569",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 569)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_570",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 570)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_571",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 571)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_572",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 572)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_573",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 573)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_574",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 574)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_575",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 575)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_576",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 576)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_577",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 577)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_578",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 578)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_579",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 579)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_580",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 580)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_581",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 581)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_582",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 582)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_583",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 583)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_584",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 584)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_585",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 585)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_586",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 586)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_587",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 587)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_588",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 588)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_589",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 589)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_590",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 590)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_591",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 591)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_592",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 592)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_593",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 593)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_594",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 594)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_595",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 595)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_596",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 596)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_597",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 597)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_598",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 598)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_599",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 599)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_600",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 600)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_601",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 601)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_602",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 602)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_603",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 603)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_604",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 604)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_605",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 605)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_606",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 606)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_607",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 607)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_608",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 608)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_609",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 609)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_610",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 610)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_611",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 611)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_612",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 612)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_613",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 613)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_614",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 614)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_615",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 615)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_616",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 616)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_617",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 617)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_618",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 618)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_619",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 619)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_620",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 620)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_621",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 621)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_622",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 622)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_623",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 623)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_624",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 624)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_625",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 625)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_626",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 626)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_627",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 627)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_628",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 628)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_629",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 629)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_630",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 630)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_631",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 631)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_632",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 632)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_633",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 633)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_634",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 634)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_635",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 635)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_636",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 636)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_637",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 637)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_638",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 638)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_639",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 639)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_640",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 640)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_641",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 641)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_642",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 642)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_643",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 643)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_644",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 644)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_645",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 645)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_646",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 646)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_647",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 647)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_648",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 648)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_649",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 649)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_650",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 650)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_651",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 651)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_652",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 652)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_653",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 653)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_654",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 654)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_655",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 655)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_656",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 656)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_657",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 657)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_658",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 658)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_659",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 659)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_660",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 660)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_661",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 661)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_662",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 662)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_663",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 663)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_664",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 664)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_665",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 665)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_666",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 666)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_667",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 667)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_668",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 668)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_669",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 669)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_670",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 670)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_671",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 671)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_672",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 672)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_673",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 673)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_674",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 674)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_675",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 675)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_676",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 676)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_677",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 677)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_678",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 678)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_679",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 679)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_680",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 680)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_681",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 681)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_682",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 682)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_683",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 683)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_684",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 684)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_685",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 685)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_686",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 686)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_687",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 687)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_688",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 688)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_689",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 689)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_690",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 690)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_691",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 691)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_692",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 692)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_693",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 693)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_694",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 694)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_695",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 695)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_696",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 696)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_697",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 697)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_698",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 698)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_699",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 699)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_700",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 700)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_701",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 701)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_702",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 702)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_703",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 703)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_704",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 704)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_705",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 705)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_706",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 706)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_707",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 707)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_708",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 708)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_709",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 709)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_710",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 710)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_711",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 711)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_712",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 712)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_713",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 713)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_714",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 714)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_715",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 715)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_716",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 716)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_717",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 717)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_718",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 718)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_719",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 719)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_720",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 720)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_721",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 721)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_722",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 722)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_723",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 723)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_724",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 724)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_725",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 725)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_726",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 726)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_727",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 727)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_728",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 728)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_729",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 729)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_730",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 730)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_731",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 731)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_732",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 732)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_733",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 733)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_734",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 734)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_735",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 735)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_736",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 736)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_737",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 737)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_738",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 738)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_739",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 739)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_740",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 740)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_741",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 741)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_742",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 742)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_743",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 743)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_744",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 744)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_745",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 745)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_746",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 746)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_747",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 747)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_748",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 748)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_749",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 749)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_750",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 750)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_751",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 751)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_752",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 752)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_753",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 753)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_754",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 754)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_755",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 755)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_756",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 756)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_757",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 757)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_758",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 758)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_759",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 759)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_760",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 760)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_761",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 761)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_762",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 762)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_763",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 763)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_764",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 764)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_765",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 765)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_766",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 766)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_767",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 767)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_768",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 768)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_769",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 769)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_770",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 770)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_771",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 771)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_772",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 772)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_773",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 773)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_774",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 774)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_775",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 775)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_776",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 776)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_777",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 777)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_778",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 778)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_779",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 779)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_780",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 780)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_781",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 781)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_782",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 782)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_783",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 783)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_784",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 784)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_785",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 785)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_786",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 786)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_787",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 787)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_788",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 788)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_789",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 789)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_790",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 790)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_791",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 791)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_792",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 792)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_793",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 793)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_794",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 794)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_795",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 795)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_796",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 796)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_797",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 797)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_798",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 798)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_799",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 799)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_800",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 800)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_801",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 801)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_802",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 802)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_803",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 803)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_804",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 804)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_805",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 805)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_806",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 806)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_807",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 807)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_808",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 808)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_809",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 809)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_810",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 810)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_811",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 811)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_812",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 812)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_813",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 813)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_814",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 814)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_815",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 815)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_816",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 816)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_817",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 817)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_818",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 818)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_819",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 819)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_820",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 820)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_821",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 821)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_822",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 822)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_823",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 823)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_824",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 824)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_825",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 825)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_826",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 826)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_827",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 827)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_828",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 828)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_829",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 829)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_830",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 830)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_831",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 831)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_832",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 832)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_833",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 833)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_834",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 834)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_835",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 835)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_836",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 836)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_837",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 837)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_838",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 838)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_839",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 839)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_840",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 840)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_841",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 841)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_842",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 842)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_843",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 843)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_844",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 844)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_845",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 845)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_846",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 846)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_847",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 847)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_848",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 848)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_849",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 849)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_850",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 850)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_851",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 851)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_852",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 852)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_853",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 853)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_854",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 854)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_855",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 855)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_856",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 856)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_857",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 857)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_858",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 858)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_859",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 859)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_860",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 860)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_861",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 861)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_862",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 862)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_863",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 863)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_864",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 864)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_865",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 865)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_866",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 866)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_867",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 867)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_868",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 868)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_869",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 869)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_870",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 870)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_871",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 871)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_872",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 872)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_873",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 873)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_874",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 874)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_875",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 875)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_876",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 876)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_877",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 877)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_878",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 878)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_879",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 879)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_880",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 880)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_881",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 881)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_882",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 882)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_883",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 883)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_884",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 884)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_885",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 885)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_886",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 886)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_887",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 887)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_888",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 888)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_889",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 889)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_890",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 890)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_891",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 891)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_892",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 892)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_893",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 893)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_894",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 894)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_895",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 895)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_896",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 896)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_897",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 897)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_898",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 898)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_899",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 899)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_900",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 900)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_901",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 901)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_902",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 902)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_903",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 903)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_904",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 904)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_905",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 905)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_906",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 906)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_907",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 907)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_908",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 908)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_909",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 909)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_910",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 910)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_911",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 911)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_912",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 912)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_913",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 913)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_914",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 914)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_915",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 915)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_916",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 916)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_917",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 917)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_918",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 918)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_919",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 919)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_920",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 920)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_921",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 921)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_922",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 922)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_923",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 923)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_924",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 924)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_925",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 925)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_926",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 926)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_927",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 927)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_928",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 928)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_929",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 929)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_930",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 930)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_931",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 931)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_932",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 932)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_933",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 933)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_934",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 934)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_935",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 935)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_936",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 936)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_937",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 937)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_938",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 938)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_939",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 939)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_940",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 940)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_941",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 941)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_942",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 942)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_943",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 943)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_944",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 944)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_945",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 945)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_946",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 946)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_947",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 947)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_948",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 948)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_949",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 949)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_950",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 950)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_951",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 951)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_952",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 952)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_953",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 953)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_954",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 954)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_955",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 955)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_956",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 956)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_957",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 957)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_958",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 958)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_959",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 959)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_960",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 960)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_961",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 961)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_962",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 962)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_963",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 963)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_964",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 964)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_965",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 965)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_966",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 966)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_967",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 967)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_968",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 968)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_969",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 969)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_970",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 970)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_971",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 971)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_972",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 972)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_973",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 973)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_974",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 974)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_975",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 975)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_976",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 976)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_977",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 977)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_978",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 978)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_979",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 979)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_980",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 980)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_981",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 981)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_982",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 982)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_983",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 983)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_984",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 984)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_985",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 985)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_986",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 986)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_987",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 987)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_988",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 988)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_989",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 989)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_990",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. (Variation 990)",
    "answer": "We can use a Hash Map to store the difference between the target and the current number. As we iterate through the array, if the difference exists in the map, we have found the pair.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [seen[complement], i]\n            seen[num] = i\n        return []"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> seen;\n        for (int i = 0; i < nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[nums[i]] = i;\n        }\n        return {};\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_991",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 991)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_992",
    "topic": "Coding Challenges",
    "difficulty": "Advanced",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 992)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_993",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Merge k Sorted Lists: You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. (Variation 993)",
    "answer": "Use a Min-Heap (Priority Queue) to keep track of the smallest element among the heads of the k lists. Repeatedly extract the minimum and add the next node from that list to the heap.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for (ListNode node : lists) {\n            if (node != null) pq.add(node);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while (!pq.isEmpty()) {\n            ListNode node = pq.poll();\n            curr.next = node;\n            curr = curr.next;\n            if (node.next != null) pq.add(node.next);\n        }\n        return dummy.next;\n    }\n}"
      }
    ]
  },
  {
    "id": "code_gen_994",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 994)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_995",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 995)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_996",
    "topic": "Coding Challenges",
    "difficulty": "Basic",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 996)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_997",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Longest Substring Without Repeating Characters: Given a string s, find the length of the longest substring without repeating characters. (Variation 997)",
    "answer": "Use a sliding window approach with a hash map or set to keep track of characters in the current window.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                start = Math.max(start, map.get(c) + 1);\n            }\n            map.put(c, end);\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return maxLen;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        start = 0\n        max_len = 0\n        for end, char in enumerate(s):\n            if char in seen:\n                start = max(start, seen[char] + 1)\n            seen[char] = end\n            max_len = max(max_len, end - start + 1)\n        return max_len"
      }
    ]
  },
  {
    "id": "code_gen_998",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 998)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_999",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Reverse Linked List: Given the head of a singly linked list, reverse the list, and return the reversed list. (Variation 999)",
    "answer": "Iterate through the list, keeping track of the previous node. For each node, save the next node, point the current node's next to the previous node, update previous to current, and current to the saved next.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        prev = None\n        curr = head\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};"
      }
    ]
  },
  {
    "id": "code_gen_1000",
    "topic": "Coding Challenges",
    "difficulty": "Intermediate",
    "question": "Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. (Variation 1000)",
    "answer": "Use two pointers, one at the start and one at the end of the string. Move them towards each other, skipping non-alphanumeric characters, and comparing the characters.",
    "codeSnippets": [
      {
        "lang": "Java",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i < j && !Character.isLetterOrDigit(s.charAt(j))) j--;\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) return false;\n            i++; j--;\n        }\n        return true;\n    }\n}"
      },
      {
        "lang": "Python",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        clean_s = ''.join(c.lower() for c in s if c.isalnum())\n        return clean_s == clean_s[::-1]"
      },
      {
        "lang": "C++",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            while (i < j && !isalnum(s[i])) i++;\n            while (i < j && !isalnum(s[j])) j--;\n            if (i < j && tolower(s[i]) != tolower(s[j])) return false;\n            i++; j--;\n        }\n        return true;\n    }\n};"
      }
    ]
  }
]